```mdx
---
title: State Management
description: State management patterns and strategies in Task Dojo
---

State Management Overview

Task Dojo uses multiple state management strategies based on scope and complexity:

Local Component State (`useState`) - UI state within a component
Lifted State - Shared between parent/children
Context API - Global app settings (accessibility)
Server State - Data from API (tasks, profile)

<Note>
No Redux/Zustand/MobX - Task Dojo intentionally keeps state management simple with built-in React tools.
</Note>

---

State Types

1. Local Component State

Use for:
Toggle states (expanded/collapsed)
Form inputs
Loading indicators
Modal open/closed

```typescript
function TaskCard({ task }: Props) {
  // Local UI state
  const [expanded, setExpanded] = useState(false)
  const [editing, setEditing] = useState(false)
  
  return (
    <Card>
      <Button onClick={() => setExpanded(!expanded)}>
        {expanded ? 'Collapse' : 'Expand'}
      </Button>
      
      {expanded && (
        <TaskDetails 
          task={task}
          editing={editing}
          onEdit={() => setEditing(true)}
        />
      )}
    </Card>
  )
}
```

Benefits:
✅ Simple and straightforward
✅ No prop drilling
✅ Easy to reason about

Limitations:
❌ Can't share with other components
❌ Lost on unmount

---

2. Lifted State

Use for:
Coordinating multiple child components
Parent needs to know child state
Siblings need to share state

```typescript
function Dashboard() {
  // Lifted state - shared by multiple components
  const [selectedTask, setSelectedTask] = useState<Task | null>(null)
  const [filter, setFilter] = useState<'all' | 'pending' | 'completed'>('all')
  
  return (
    <div>
      {/* Both components use lifted state */}
      <FilterBar 
        activeFilter={filter}
        onChange={setFilter}
      />
      
      <TasksList 
        tasks={tasks}
        filter={filter}
        selectedTask={selectedTask}
        onSelect={setSelectedTask}
      />
      
      {selectedTask && (
        <TaskDetail task={selectedTask} />
      )}
    </div>
  )
}
```

Benefits:
✅ Coordinates multiple components
✅ Single source of truth
✅ Easy to understand data flow

Limitations:
❌ Can lead to prop drilling if too deep
❌ Parent re-renders when state changes

---

3. Context API

Use for:
Global app settings
User preferences
Theme/accessibility
Data needed everywhere

Accessibility Context

```typescript
// utils/accessibility-context.tsx
interface AccessibilitySettings {
  reducedMotion: boolean
  dyslexiaFont: boolean
  fontSize: number
  highContrast: boolean
}

const AccessibilityContext = createContext<{
  settings: AccessibilitySettings
  updateSettings: (updates: Partial<AccessibilitySettings>) => void
}>(null!)

export function AccessibilityProvider({ children }: { children: ReactNode }) {
  const [settings, setSettings] = useState<AccessibilitySettings>(() => {
    const saved = localStorage.getItem('accessibility-settings')
    return saved ? JSON.parse(saved) : {
      reducedMotion: false,
      dyslexiaFont: false,
      fontSize: 100,
      highContrast: false
    }
  })
  
  const updateSettings = useCallback((updates: Partial<AccessibilitySettings>) => {
    setSettings(prev => {
      const newSettings = { ...prev, ...updates }
      localStorage.setItem('accessibility-settings', JSON.stringify(newSettings))
      return newSettings
    })
  }, [])
  
  return (
    <AccessibilityContext.Provider value={{ settings, updateSettings }}>
      {children}
    </AccessibilityContext.Provider>
  )
}

export function useAccessibility() {
  const context = useContext(AccessibilityContext)
  if (!context) throw new Error('useAccessibility must be used within AccessibilityProvider')
  return context
}
```

Using Context

```typescript
// Any component, any depth
function Settings() {
  const { settings, updateSettings } = useAccessibility()
  
  return (
    <div>
      <Switch 
        checked={settings.reducedMotion}
        onCheckedChange={(checked) => 
          updateSettings({ reducedMotion: checked })
        }
      />
      
      <Slider 
        value={[settings.fontSize]}
        onValueChange={([fontSize]) => 
          updateSettings({ fontSize })
        }
      />
    </div>
  )
}

// Celebration respects reduced motion
function CompletionCelebration() {
  const { settings } = useAccessibility()
  
  return (
    <div>
      {!settings.reducedMotion && <ConfettiEffect />}
      <h2 style={{ fontSize: `${settings.fontSize}%` }}>
        Great Work!
      </h2>
    </div>
  )
}
```

Benefits:
✅ No prop drilling
✅ Global access
✅ Persists to localStorage

Limitations:
❌ All consumers re-render on change
❌ Can be overused

---

4. Server State

Use for:
API data (tasks, profile, disciples)
Asynchronous data
Data that needs to stay in sync with backend

```typescript
function Dashboard({ profile }: Props) {
  const [tasks, setTasks] = useState<Task[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  
  // Load server data
  useEffect(() => {
    getTasks()
      .then(result => {
        setTasks(result.tasks)
        setLoading(false)
      })
      .catch(err => {
        setError(err.message)
        setLoading(false)
      })
  }, [])
  
  // Update server data
  const handleComplete = async (taskId: string, quality: number) => {
    const result = await completeTask(taskId, quality)
    
    // Optimistic update
    setTasks(prev => prev.map(task =>
      task.id === taskId ? { ...task, completed: true } : task
    ))
    
    return result
  }
  
  if (loading) return <Skeleton />
  if (error) return <ErrorMessage error={error} />
  
  return <TasksList tasks={tasks} onComplete={handleComplete} />
}
```

---

State Update Patterns

Immutable Updates

Always create new objects/arrays:

```typescript
// ✅ Good: Immutable updates
setTasks(prev => [...prev, newTask])
setTasks(prev => prev.filter(t => t.id !== taskId))
setTasks(prev => prev.map(t => 
  t.id === taskId ? { ...t, completed: true } : t
))

// ❌ Avoid: Mutating state
setTasks(prev => {
  prev.push(newTask)  // WRONG!
  return prev
})

setTasks(prev => {
  prev[0].completed = true  // WRONG!
  return prev
})
```

Functional Updates

Use when new state depends on old state:

```typescript
// ✅ Good: Functional update
setCount(prev => prev + 1)

// ⚠️ Risky: Direct update
setCount(count + 1)  // May be stale
```

Batch Updates

React 18+ automatically batches:

```typescript
function handleSubmit() {
  // All setStates batched into one re-render
  setLoading(true)
  setError(null)
  setSuccess(false)
  
  // Only ONE re-render happens!
}
```

---

Custom Hooks for State Logic

useTasks Hook

Extract reusable task state logic:

```typescript
// hooks/useTasks.ts
export function useTasks() {
  const [tasks, setTasks] = useState<Task[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  
  const loadTasks = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)
      const result = await getTasks()
      setTasks(result.tasks)
    } catch (err) {
      setError(err.message)
      console.error('Failed to load tasks:', err)
    } finally {
      setLoading(false)
    }
  }, [])
  
  useEffect(() => {
    loadTasks()
  }, [loadTasks])
  
  const createTask = useCallback(async (taskData: CreateTaskInput) => {
    const newTask = await createTaskAPI(taskData)
    setTasks(prev => [newTask, ...prev])
    return newTask
  }, [])
  
  const completeTask = useCallback(async (taskId: string, quality: number) => {
    const result = await completeTaskAPI(taskId, quality)
    setTasks(prev => prev.map(task =>
      task.id === taskId ? { ...task, completed: true, quality } : task
    ))
    return result
  }, [])
  
  const deleteTask = useCallback(async (taskId: string) => {
    await deleteTaskAPI(taskId)
    setTasks(prev => prev.filter(task => task.id !== taskId))
  }, [])
  
  return {
    tasks,
    loading,
    error,
    reload: loadTasks,
    createTask,
    completeTask,
    deleteTask
  }
}

// Usage:
function Dashboard() {
  const { tasks, loading, error, completeTask } = useTasks()
  
  if (loading) return <Skeleton />
  if (error) return <ErrorMessage error={error} />
  
  return <TasksList tasks={tasks} onComplete={completeTask} />
}
```

---

useProfile Hook

```typescript
export function useProfile() {
  const [profile, setProfile] = useState<Profile | null>(null)
  const [loading, setLoading] = useState(true)
  
  const loadProfile = useCallback(async () => {
    const data = await getProfile()
    setProfile(data.profile)
    setLoading(false)
  }, [])
  
  useEffect(() => {
    loadProfile()
  }, [loadProfile])
  
  const updateProfile = useCallback(async (updates: Partial<Profile>) => {
    const updated = await updateProfileAPI(updates)
    setProfile(updated)
    return updated
  }, [])
  
  return { profile, loading, reload: loadProfile, updateProfile }
}
```

---

Optimistic Updates

Update UI immediately, rollback on error:

```typescript
function TasksList() {
  const [tasks, setTasks] = useState<Task[]>([])
  
  const handleComplete = async (taskId: string) => {
    // 1. Optimistically update UI
    const previousTasks = tasks
    setTasks(prev => prev.map(task =>
      task.id === taskId ? { ...task, completed: true } : task
    ))
    
    try {
      // 2. Send to server
      await completeTask(taskId)
      toast.success('Task completed!')
    } catch (error) {
      // 3. Rollback on error
      setTasks(previousTasks)
      toast.error('Failed to complete task')
      console.error(error)
    }
  }
  
  return <TasksList tasks={tasks} onComplete={handleComplete} />
}
```

Benefits:
✅ Instant UI feedback
✅ Better user experience
✅ Feels fast

Considerations:
⚠️ Need rollback logic
⚠️ Handle conflicts carefully

---

State Debugging

React DevTools

Install: React DevTools Extension

Features:
Inspect component props and state
Trace state updates
Profile performance
Highlight re-renders

Manual Logging

```typescript
function Dashboard() {
  const [tasks, setTasks] = useState<Task[]>([])
  
  // Log state changes in development
  useEffect(() => {
    if (import.meta.env.DEV) {
      console.log('Tasks updated:', tasks)
    }
  }, [tasks])
  
  return <TasksList tasks={tasks} />
}
```

State Inspection

```typescript
// Debug hook to inspect state changes
function useStateDebug<T>(state: T, name: string) {
  const prevState = useRef(state)
  
  useEffect(() => {
    if (prevState.current !== state) {
      console.log(`${name} changed:`, {
        previous: prevState.current,
        current: state
      })
      prevState.current = state
    }
  }, [state, name])
}

// Usage:
const [tasks, setTasks] = useState<Task[]>([])
useStateDebug(tasks, 'tasks')
```

---

Common Patterns

Loading States

```typescript
function Dashboard() {
  const [tasks, setTasks] = useState<Task[]>([])
  const [loading, setLoading] = useState(true)
  
  useEffect(() => {
    setLoading(true)
    getTasks()
      .then(setTasks)
      .finally(() => setLoading(false))
  }, [])
  
  if (loading) return <Skeleton />
  return <TasksList tasks={tasks} />
}
```

Error States

```typescript
function Dashboard() {
  const [error, setError] = useState<string | null>(null)
  
  const handleAction = async () => {
    try {
      setError(null)
      await performAction()
    } catch (err) {
      setError(err.message)
    }
  }
  
  return (
    <>
      {error && <Alert variant="destructive">{error}</Alert>}
      <Button onClick={handleAction}>Perform Action</Button>
    </>
  )
}
```

Pagination State

```typescript
function TasksList() {
  const [tasks, setTasks] = useState<Task[]>([])
  const [page, setPage] = useState(0)
  const [hasMore, setHasMore] = useState(true)
  
  const loadMore = async () => {
    const result = await getTasks({ page: page + 1, limit: 50 })
    setTasks(prev => [...prev, ...result.tasks])
    setPage(prev => prev + 1)
    setHasMore(result.pagination.hasMore)
  }
  
  return (
    <>
      <TasksList tasks={tasks} />
      {hasMore && <Button onClick={loadMore}>Load More</Button>}
    </>
  )
}
```

---

State Anti-Patterns

❌ Storing Derived State

```typescript
// ❌ Bad: Storing filtered tasks in state
const [tasks, setTasks] = useState<Task[]>([])
const [filteredTasks, setFilteredTasks] = useState<Task[]>([])

useEffect(() => {
  setFilteredTasks(tasks.filter(t => !t.completed))
}, [tasks])

// ✅ Good: Calculate on render
const filteredTasks = useMemo(() => 
  tasks.filter(t => !t.completed),
  [tasks]
)
```

❌ Prop-to-State Duplication

```typescript
// ❌ Bad: Copying props to state
function TaskCard({ task }: Props) {
  const [localTask, setLocalTask] = useState(task)
  
  // State diverges from prop!
  return <div>{localTask.title}</div>
}

// ✅ Good: Use prop directly
function TaskCard({ task }: Props) {
  return <div>{task.title}</div>
}
```

❌ Over-using Context

```typescript
// ❌ Bad: Context for everything
<TasksContext.Provider>
  <FilterContext.Provider>
    <SelectedTaskContext.Provider>
      <LoadingContext.Provider>
        {/* Context hell */}
      </LoadingContext.Provider>
    </SelectedTaskContext.Provider>
  </FilterContext.Provider>
</TasksContext.Provider>

// ✅ Good: Use props or lift state
<TasksContainer 
  filter={filter}
  selectedTask={selectedTask}
  loading={loading}
/>
```

---

Performance Optimization

Memoization

Prevent expensive recalculations:

```typescript
const sortedTasks = useMemo(() => {
  return [...tasks].sort((a, b) => 
    new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
  )
}, [tasks])

const filteredTasks = useMemo(() => {
  return sortedTasks.filter(task => 
    filter === 'all' || 
    (filter === 'completed' && task.completed) ||
    (filter === 'pending' && !task.completed)
  )
}, [sortedTasks, filter])
```

Callback Memoization

Prevent child re-renders:

```typescript
const handleComplete = useCallback(async (taskId: string) => {
  await completeTask(taskId)
  loadTasks()
}, [loadTasks])

return <TaskCard task={task} onComplete={handleComplete} />
```

---

Testing State Logic

```typescript
import { renderHook, act } from '@testing-library/react'
import { useTasks } from './useTasks'

describe('useTasks', () => {
  it('should load tasks on mount', async () => {
    const { result } = renderHook(() => useTasks())
    
    expect(result.current.loading).toBe(true)
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false)
    })
    
    expect(result.current.tasks.length).toBeGreaterThan(0)
  })
  
  it('should complete task', async () => {
    const { result } = renderHook(() => useTasks())
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false)
    })
    
    await act(async () => {
      await result.current.completeTask('task-1', 5)
    })
    
    const task = result.current.tasks.find(t => t.id === 'task-1')
    expect(task?.completed).toBe(true)
  })
})
```

---

Next Steps

<CardGroup cols={2}>
  <Card title="Component Structure" icon="shapes" href="/technical/development/component-structure">
    How components use state
  </Card>
  
  <Card title="Testing" icon="vial" href="/technical/development/testing">
    Test state logic
  </Card>
  
  <Card title="Performance" icon="gauge" href="/technical/performance">
    Optimize state updates
  </Card>
  
  <Card title="Architecture" icon="sitemap" href="/technical/architecture">
    Overall system design
  </Card>
</CardGroup>

---

<Check>
Keep state simple! Use local state by default, lift when needed, Context sparingly, and custom hooks for reusable logic. Optimize with memo/callback only when necessary.
</Check>
```
