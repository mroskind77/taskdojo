```mdx
---
title: System Architecture
description: Detailed architecture and design patterns for Task Dojo
---

Architecture Overview

Task Dojo follows a three-tier architecture pattern with clear separation between presentation, business logic, and data persistence layers.

```
┌─────────────────────────────────────────────────────────┐
│                    CLIENT TIER                           │
│  ┌───────────────────────────────────────────────────┐  │
│  │            React SPA (Vite + TypeScript)          │  │
│  │  ┌───────────┬────────────┬──────────────────┐   │  │
│  │  │Components │   State    │     Styling      │   │  │
│  │  │  - Tasks  │ - useState │  - Tailwind CSS  │   │  │
│  │  │  - Profile│ - Context  │  - shadcn/ui     │   │  │
│  │  │  - Sensei │ - Hooks    │  - Custom tokens │   │  │
│  │  └───────────┴────────────┴──────────────────┘   │  │
│  └───────────────────────────────────────────────────┘  │
└────────────────────┬────────────────────────────────────┘
                     │ HTTPS (REST API)
                     │ Authorization: Bearer {access_token}
┌────────────────────▼────────────────────────────────────┐
│                   SERVER TIER                            │
│  ┌───────────────────────────────────────────────────┐  │
│  │    Supabase Edge Functions (Deno Runtime)        │  │
│  │  ┌───────────────────────────────────────────┐   │  │
│  │  │       Hono Web Server Framework           │   │  │
│  │  │                                           │   │  │
│  │  │  Routes:                                  │   │  │
│  │  │  - /auth/* - Authentication               │   │  │
│  │  │  - /profile/* - User profiles             │   │  │
│  │  │  - /tasks/* - Task CRUD                   │   │  │
│  │  │  - /sensei/* - Sensei operations          │   │  │
│  │  │  - /ai/* - AI decomposition               │   │  │
│  │  │  - /intercom/* - Identity verification    │   │  │
│  │  │                                           │   │  │
│  │  │  Middleware:                              │   │  │
│  │  │  - CORS                                   │   │  │
│  │  │  - Logger                                 │   │  │
│  │  │  - Error handler                          │   │  │
│  │  └───────────────────────────────────────────┘   │  │
│  └───────────────────────────────────────────────────┘  │
└────────────┬──────────────────┬─────────────────────────┘
             │                  │
             │                  │ External APIs
         ┌───▼──────────┐  ┌───▼────────────────┐
         │  DATA TIER   │  │  EXTERNAL SERVICES │
         └──────────────┘  └────────────────────┘
```

---

Client Tier (Frontend)

React Application Structure

```
/
├── App.tsx                 # Root component, routing
├── components/             # React components
│   ├── Dashboard.tsx       # Main dashboard
│   ├── Tasks.tsx           # Task management
│   ├── Profile.tsx         # User profile
│   ├── Disciples.tsx       # Sensei disciple management
│   ├── Achievements.tsx    # Achievement display
│   ├── Settings.tsx        # User settings
│   └── ui/                 # shadcn/ui components
├── utils/                  # Utility functions
│   ├── api.ts              # API client
│   ├── belt-colors.ts      # Belt logic
│   ├── avatar-skins.ts     # Avatar system
│   ├── preset-tasks.ts     # Template library
│   ├── message-variations.ts # Copy variations
│   └── accessibility-context.tsx # A11y state
└── styles/
    └── globals.css         # Global styles & tokens
```

Component Architecture

Container/Presentational Pattern:

```typescript
// Container component (logic)
function TasksContainer() {
  const [tasks, setTasks] = useState<Task[]>([])
  const [loading, setLoading] = useState(true)
  
  useEffect(() => {
    loadTasks()
  }, [])
  
  async function loadTasks() {
    const result = await getTasks()
    setTasks(result.tasks)
    setLoading(false)
  }
  
  return <TasksList tasks={tasks} loading={loading} onComplete={handleComplete} />
}

// Presentational component (UI)
function TasksList({ tasks, loading, onComplete }: TasksListProps) {
  if (loading) return <TasksSkeleton />
  
  return (
    <div className="space-y-4">
      {tasks.map(task => (
        <TaskCard key={task.id} task={task} onComplete={onComplete} />
      ))}
    </div>
  )
}
```

State Management

Local State (useState):
Component-specific UI state
Form inputs
Loading states
Temporary data

Context API (React Context):
Global accessibility settings
User preferences
Theme/dark mode

Server State (API calls):
User profile
Tasks
Disciples
Achievements
Insights

No Redux/Zustand: Simple architecture with direct API calls and React state.

---

Server Tier (Backend)

Supabase Edge Functions

Runtime: Deno (TypeScript-first JavaScript runtime)

Location: `/supabase/functions/server/`

Entry Point: `index.tsx`

```typescript
import { Hono } from 'npm:hono@4'
import { cors } from 'npm:hono/cors'
import { logger } from 'npm:hono/logger'

const app = new Hono()

// Global middleware
app.use('*', cors({
  origin: '*',  // Open CORS for frontend access
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
}))

app.use('*', logger(console.log))

// Route groups
app.route('/make-server-4010be06/auth', authRoutes)
app.route('/make-server-4010be06/profile', profileRoutes)
app.route('/make-server-4010be06/tasks', taskRoutes)
app.route('/make-server-4010be06/sensei', senseiRoutes)
app.route('/make-server-4010be06/ai', aiRoutes)
app.route('/make-server-4010be06/intercom', intercomRoutes)

// Error handling
app.onError((err, c) => {
  console.error(`Error: ${err}`)
  return c.json({ error: err.message }, 500)
})

Deno.serve(app.fetch)
```

Hono Framework

Why Hono?
Extremely fast and lightweight
TypeScript-first
Middleware support
Excellent DX
Works natively on Deno

Request/Response Flow:

```typescript
// Example route with validation and auth
app.post('/tasks', async (c) => {
  // 1. Validate auth token
  const token = c.req.header('Authorization')?.split(' ')[1]
  const { data: { user }, error } = await supabase.auth.getUser(token)
  
  if (!user) {
    return c.json({ error: 'Unauthorized' }, 401)
  }
  
  // 2. Parse and validate body
  const body = await c.req.json()
  if (!body.title || !body.category) {
    return c.json({ error: 'Missing required fields' }, 400)
  }
  
  // 3. Business logic
  const task = await createTask({
    userId: user.id,
    ...body
  })
  
  // 4. Return response
  return c.json({ task }, 201)
})
```

Data Access Layer

KV Store Pattern:

```typescript
// /supabase/functions/server/kv_store.tsx
import { createClient } from 'jsr:@supabase/supabase-js@2'

const supabase = createClient(
  Deno.env.get('SUPABASE_URL')!,
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
)

export async function get(key: string) {
  const { data, error } = await supabase
    .from('kv_store_4010be06')
    .select('value')
    .eq('key', key)
    .single()
  
  return data ? JSON.parse(data.value) : null
}

export async function set(key: string, value: any) {
  const { error } = await supabase
    .from('kv_store_4010be06')
    .upsert({ key, value: JSON.stringify(value) })
  
  if (error) throw error
}

export async function del(key: string) {
  const { error } = await supabase
    .from('kv_store_4010be06')
    .delete()
    .eq('key', key)
  
  if (error) throw error
}

export async function getByPrefix(prefix: string) {
  const { data, error } = await supabase
    .from('kv_store_4010be06')
    .select('key, value')
    .like('key', `${prefix}%`)
  
  if (error) throw error
  return data.map(row => JSON.parse(row.value))
}
```

Key Patterns:
`profile:{userId}` - User profiles
`task:{userId}:{taskId}` - User tasks
`insights:{userId}` - Cached insights
`template:{category}` - Template library

---

Data Tier

Database Schema

Single Table Design (KV Store):

```sql
CREATE TABLE kv_store_4010be06 (
  key TEXT PRIMARY KEY,
  value JSONB NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_kv_prefix ON kv_store_4010be06 USING btree (key text_pattern_ops);
CREATE INDEX idx_kv_value ON kv_store_4010be06 USING gin (value);
```

Why Single Table?
✅ Simplifies schema management
✅ Flexible data model
✅ Easy to query by prefix
✅ JSONB supports complex queries
✅ No migrations needed
❌ Trades some query performance for flexibility

Supabase Auth

Built-in authentication system:

```typescript
// Create user
const { data, error } = await supabase.auth.admin.createUser({
  email: 'user@example.com',
  password: 'secure-password',
  email_confirm: true,  // Auto-confirm (no email server)
  user_metadata: {
    name: 'John Doe',
    userType: 'master',
    ageCategory: 'mantis'
  }
})

// Sign in
const { data: { session }, error } = await supabase.auth.signInWithPassword({
  email: 'user@example.com',
  password: 'secure-password'
})

// Verify token
const { data: { user }, error } = await supabase.auth.getUser(accessToken)
```

Session Management:
Access tokens stored client-side (memory)
Server validates tokens on every request
No session cookies (stateless)
Tokens expire after configured TTL

---

External Services

Intercom Integration

Purpose: Customer support and user engagement

Architecture Pattern: Identity Verification

```typescript
// Server-side hash generation
function generateUserHash(userId: string): string {
  const secret = Deno.env.get('INTERCOM_IDENTITY_VERIFICATION_SECRET')
  return crypto.createHmac('sha256', secret)
    .update(userId)
    .digest('hex')
}

// Frontend initialization
Intercom('boot', {\n  app_id: 'YOUR_APP_ID',
  user_id: userId,
  user_hash: userHash,  // From server
  name: userName,
  email: userEmail,
  created_at: createdAtTimestamp
})
```

Security: User hash prevents spoofing user identity

AI Service Integration

Providers: OpenAI or Anthropic (configurable)

Purpose: AI-powered task breakdown

```typescript
async function generateTaskBreakdown(taskDescription: string) {
  const apiKey = Deno.env.get('OPENAI_API_KEY')
  
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      model: 'gpt-4',
      messages: [{
        role: 'system',
        content: 'You are a helpful assistant that breaks complex tasks into manageable steps.'
      }, {
        role: 'user',
        content: `Break this task into 5-7 specific sub-tasks: ${taskDescription}`
      }],
      temperature: 0.7
    })
  })
  
  const data = await response.json()
  return parseSubTasks(data.choices[0].message.content)
}
```

Rate Limiting: Client-side debouncing + server-side throttling

---

Cross-Cutting Concerns

Error Handling

Client-Side:

```typescript
async function handleApiCall<T>(apiCall: () => Promise<T>): Promise<T> {
  try {
    return await apiCall()
  } catch (error) {
    if (error.status === 401) {
      // Redirect to login
      window.location.href = '/signin'
    } else if (error.status >= 500) {
      toast.error('Something went sideways on our end. Let\'s try that again.')
    } else {
      toast.error(error.message || 'Something went sideways. Let\'s try that again.')
    }
    throw error
  }
}
```

Server-Side:

```typescript
app.onError((err, c) => {
  console.error(`${new Date().toISOString()} - Error: ${err.message}`, {
    stack: err.stack,
    path: c.req.path,
    method: c.req.method
  })
  
  // Don't leak internal errors to client
  const message = err.status >= 500 
    ? 'Internal server error'
    : err.message
  
  return c.json({ error: message }, err.status || 500)
})
```

Logging

Server Logging:

```typescript
import { logger } from 'npm:hono/logger'

app.use('*', logger((message) => {
  console.log(message)
}))

// Custom structured logging
function logEvent(event: string, metadata: any) {
  console.log(JSON.stringify({
    timestamp: new Date().toISOString(),
    event,
    ...metadata
  }))
}
```

Client Logging:

```typescript
// Development only
if (import.meta.env.DEV) {
  console.log('API Call:', endpoint, body)
}

// Production: Intercom event tracking
Intercom('trackEvent', 'task-completed', {
  taskId: task.id,
  category: task.category,
  points: task.points
})
```

Security

Authentication Flow:

User logs in → Server validates credentials
Server returns access token
Client stores token (memory, not localStorage)
Client sends token in Authorization header
Server validates token on every request

Authorization Rules:

```typescript
async function checkAuthorization(userId: string, resourceOwnerId: string, userType: string) {
  // Users can access their own data
  if (userId === resourceOwnerId) return true
  
  // Senseis can access disciple data
  if (userType === 'sensei') {
    const sensei = await getProfile(userId)
    if (sensei.disciples.includes(resourceOwnerId)) return true
  }
  
  return false
}
```

Never expose:
❌ SUPABASE_SERVICE_ROLE_KEY to frontend
❌ API keys to frontend
❌ Internal error details to users
❌ Other users' data

---

Performance Optimization

Frontend Optimization

Code Splitting:

```typescript
// Lazy load heavy components
const SenseiInsights = lazy(() => import('./SenseiInsights'))

function Disciples() {
  return (
    <Suspense fallback={<Skeleton />}>
      <SenseiInsights disciple={selectedDisciple} />
    </Suspense>
  )
}
```

Memoization:

```typescript
const beltProgress = useMemo(() => {
  return calculateBeltProgress(profile.points, profile.ageCategory)
}, [profile.points, profile.ageCategory])

const filteredTasks = useMemo(() => {
  return tasks.filter(task => task.category === selectedCategory)
}, [tasks, selectedCategory])
```

Debouncing:

```typescript
const debouncedSearch = useCallback(
  debounce((query: string) => {
    performSearch(query)
  }, 300),
  []
)
```

Backend Optimization

Caching Strategy:

```typescript
// Cache expensive computations
const INSIGHTS_CACHE_TTL = 5 * 60 * 1000 // 5 minutes

async function getInsights(userId: string) {
  const cacheKey = `insights:${userId}`
  const cached = await kv.get(cacheKey)
  
  if (cached && Date.now() - cached.timestamp < INSIGHTS_CACHE_TTL) {
    return cached.data
  }
  
  const fresh = await computeInsights(userId)
  await kv.set(cacheKey, { data: fresh, timestamp: Date.now() })
  return fresh
}

// Invalidate on data change
async function invalidateInsightsCache(userId: string) {
  await kv.del(`insights:${userId}`)
}
```

Batch Operations:

```typescript
// Batch fetch disciples
async function getDisciplesWithProfiles(senseiId: string) {
  const sensei = await getProfile(senseiId)
  const disciples = await Promise.all(
    sensei.disciples.map(id => getProfile(id))
  )
  return disciples
}
```

Database Optimization

Indexing:

```sql
-- Prefix queries for getByPrefix
CREATE INDEX idx_kv_prefix ON kv_store_4010be06 USING btree (key text_pattern_ops);

-- JSONB queries
CREATE INDEX idx_kv_value ON kv_store_4010be06 USING gin (value);
```

Query Patterns:

```typescript
// Good: Specific key lookup
await kv.get(`profile:${userId}`)

// Good: Prefix with limit
await kv.getByPrefix(`task:${userId}:`, { limit: 50 })

// Avoid: Full table scans
// Don't scan all tasks across all users
```

---

Deployment Architecture

Production Stack

```
┌────────────────────────────────────────────┐
│          Frontend (Vercel/Netlify)         │
│          Static React SPA build             │
└────────────────┬───────────────────────────┘
                 │ HTTPS
┌────────────────▼───────────────────────────┐
│       Supabase Edge Functions              │
│       (Global CDN distribution)            │
└────────────────┬───────────────────────────┘
                 │
┌────────────────▼───────────────────────────┐
│       Supabase PostgreSQL Database         │
│       (Multi-region replication)           │
└────────────────────────────────────────────┘
```

Environment Variables

Frontend (.env):
```bash
VITE_SUPABASE_URL=https://xxx.supabase.co
VITE_SUPABASE_ANON_KEY=eyJxxx...
VITE_INTERCOM_APP_ID=xxx
```

Backend (Supabase Secrets):
```bash
SUPABASE_URL=https://xxx.supabase.co
SUPABASE_ANON_KEY=eyJxxx...
SUPABASE_SERVICE_ROLE_KEY=eyJxxx...  # NEVER expose!
SUPABASE_DB_URL=postgresql://xxx
INTERCOM_IDENTITY_VERIFICATION_SECRET=xxx
OPENAI_API_KEY=sk-xxx  # Optional
ANTHROPIC_API_KEY=sk-xxx  # Optional
```

---

Scalability Considerations

Current Limits

Users: 10,000+ supported
Tasks per user: Unlimited (but UI shows paginated)
Disciples per Sensei: Recommended 1-5, max ~20
Concurrent requests: Edge functions auto-scale

Bottlenecks

Potential:
Large disciple lists (50+) loading slowly
Insights generation for power users (1000+ tasks)
AI breakdown rate limits

Mitigations:
Pagination on all list endpoints
Insights caching (5-minute TTL)
Client-side debouncing on AI requests
Lazy loading heavy components

---

Related Documentation

<CardGroup cols={2}>
  <Card title="Database Schema" icon="database" href="/technical/database">
    Detailed database design
  </Card>
  <Card title="API Reference" icon="code" href="/api-reference/overview">
    Complete API documentation
  </Card>
  <Card title="Security Guide" icon="shield" href="/technical/security">
    Security best practices
  </Card>
  <Card title="Performance" icon="gauge" href="/technical/performance">
    Optimization strategies
  </Card>
</CardGroup>
```
